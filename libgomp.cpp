// libgomp.cpp
//
// A subset of libgomp for bare metal.
// This is a simplistic implementation for a single-core processor for learning, development, and testing.
//
// Target is an ARM CPU with very simple bare metal threading support.

#include <stdint.h>
#include <omp.h>
#include "thread.hpp"
#include "threadFIFO.hpp"
#include "libgomp.hpp"

// The worker thread's stacks
// The thread number can be determined by  looking at certain bits of the sp.
static char gomp_stacks[GOMP_NUM_THREADS][GOMP_STACK_SIZE];

// a thread that waits for a job from OMP
typedef void JOBFN(void *);

// a job
struct job
    {
    JOBFN *fn;              // the thread function generated by OMP
    void *data;             // the thread's local data pointer
    bool done;              // a flag which indicates that the thread is done
    Thread worker;          // the thread
    };

// an array of jobs
static job jobs[GOMP_NUM_THREADS] __attribute__((__aligned__((8))));



// return the number of threads available
extern "C"
int omp_get_num_threads()
    {
    return GOMP_NUM_THREADS;
    }


extern "C"
int omp_get_thread_num()
    {
    uintptr_t sp;
    uintptr_t base = (uintptr_t)&gomp_stacks

    __asm__ __volatile__("    mov %[sp], sp" : [sp]"=r"(sp));

    return ((sp-base)>>GOMP_STACK_SHIFT) & GOMP_TID_MASK;
    }



static void gomp_worker()
    {
    int tid = omp_get_thread_num();

    jobs[tid].done = false;

    while(true)
        {
        jobs[tid].worker.suspend();

        JOBFN *fn = jobs[tid].fn;
        void *data = jobs[tid].data;
        (*fn)(data);
        jobs[tid].done = true;
        }
    }



extern "C"
void GOMP_parallel(
    JOBFN *fn,                                      // the thread code
    void *data,                                     // the local data
    unsigned num_threads,                           // the requested number of threads
    unsigned flags __attribute__((__unused__)))     // flags (ignored for now)
    {
    if(num_threads == 0 || num_threads > GOMP_NUM_THREADS)
        {
        num_threads = GOMP_NUM_THREADS;
        }


    for(int i=num_threads-1; i>=0; i--)
        {
        jobs[i].fn = fn;
        jobs[i].data = data;
        jobs[i].done = false;
        jobs[i].worker.resume();
        }
    
    for(unsigned i=0; i<num_threads; i++)
        {
        while(jobs[i].done == false)
            {
            yield();
            }
        }
    }


// Powerup initialization of libgomp.
// Must be called after thread and threadFIFO are setup.
// It spawns a pool of OMP worker threads.

void libgomp_init()
    {
    for(int i=0; i<GOMP_NUM_THREADS; i++)
        {
        Thread::spawn(gomp_worker, gomp_stacks[i]);         
        }
    }



